{
    "output_list": [
        {
            "function_name": "feeFor",
            "code": "function feeFor(address from, address to, uint256 amount) constant external returns (uint256 value) { uint256 fee = exportFee[from]; if (fee == 0) return 0; uint256 amountHeld; if (balanceOf[to] != 0) { if (validAfter[to].ts + mustHoldFor < now) amountHeld = balanceOf[to]; else amountHeld = validAfter[to].last; if (amountHeld >= singleIDXMQty) return 0; return amount*fee*(singleIDXMQty - amountHeld) / feeDivisor; } else return amount*fee / baseFeeDivisor; }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `feeFor` calculates the fee based on the balance of the recipient. If the recipient's balance is greater than or equal to `singleIDXMQty`, the fee calculation will not overflow. However, if the recipient's balance is less than `singleIDXMQty`, the fee calculation may overflow. This can be exploited by sending a large amount of tokens to the contract and then calling `feeFor` with the recipient's address as the `from` parameter. The fee calculation will then underflow, resulting in a loss of tokens."
        },
        {
            "function_name": "feeFor",
            "code": "function feeFor(address from, address to, uint256 amount) constant external returns (uint256 value) { uint256 fee = exportFee[from]; if (fee == 0) return 0; uint256 amountHeld; if (balanceOf[to] != 0) { if (validAfter[to].ts + mustHoldFor < now) amountHeld = balanceOf[to]; else amountHeld = validAfter[to].last; if (amountHeld >= singleIDXMQty) return 0; return amount*fee*(singleIDXMQty - amountHeld) / feeDivisor; } else return amount*fee / baseFeeDivisor; }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `feeFor` calculates the fee based on the balance of the recipient. If the recipient's balance is greater than or equal to `singleIDXMQty`, the fee calculation will not overflow. However, if the recipient's balance is less than `singleIDXMQty`, the fee calculation may overflow. This can be exploited by sending a large amount of tokens to the contract and then calling `feeFor` with the recipient's address as the `from` parameter. The fee calculation will then underflow, resulting in a loss of tokens."
        },
        {
            "function_name": "feeFor",
            "code": "function feeFor(address from, address to, uint256 amount) constant external returns (uint256 value) { uint256 fee = exportFee[from]; if (fee == 0) return 0; uint256 amountHeld; if (balanceOf[to] != 0) { if (validAfter[to].ts + mustHoldFor < now) amountHeld = balanceOf[to]; else amountHeld = validAfter[to].last; if (amountHeld >= singleIDXMQty) return 0; return amount*fee*(singleIDXMQty - amountHeld) / feeDivisor; } else return amount*fee / baseFeeDivisor; }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `feeFor` calculates the fee based on the balance of the recipient. If the recipient's balance is greater than or equal to `singleIDXMQty`, the fee calculation will not overflow. However, if the recipient's balance is less than `singleIDXMQty`, the fee calculation may overflow. This can be exploited by sending a large amount of tokens to the contract and then calling `feeFor` with the recipient's address as the `from` parameter. The fee calculation will then underflow, resulting in a loss of tokens."
        }
    ]
}