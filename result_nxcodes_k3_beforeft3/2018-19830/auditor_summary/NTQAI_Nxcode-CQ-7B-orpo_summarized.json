{
    "output_list": [
        {
            "function_name": "transfer",
            "code": "function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) unFrozenAccount onlyTransferable { if (frozenAccount[_to]) { InvalidAccount(_to, "The receiver account is frozen"); } else { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); } }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `transfer` does not check for integer overflow when subtracting `_value` from `balances[msg.sender]`. This could lead to an underflow if `_value` is greater than `balances[msg.sender]`. This vulnerability can be exploited by sending a large amount of tokens to the contract, causing the contract's balance to decrease, and then attempting to transfer more tokens than the contract has. This could result in the contract's balance being drained, and the attacker's tokens being lost."
        },
        {
            "function_name": "transferFrom",
            "code": "function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) unFrozenAccount onlyTransferable{ var _allowance = allowed[_from][msg.sender]; require(!frozenAccount[_from]&&!frozenAccount[_to]); balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `transferFrom` does not check for integer overflow when subtracting `_value` from `balances[_from]`. This could lead to an underflow if `_value` is greater than `balances[_from]`. This vulnerability can be exploited by sending a large amount of tokens to the contract, causing the contract's balance to decrease, and then attempting to transfer more tokens than the contract has. This could result in the contract's balance being drained, and the attacker's tokens being lost."
        },
        {
            "function_name": "approve",
            "code": "function approve(address _spender, uint _value) unFrozenAccount { if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `approve` does not check for integer overflow when subtracting `_value` from `allowed[msg.sender][_spender]`. This could lead to an underflow if `_value` is greater than `allowed[msg.sender][_spender]`. This vulnerability can be exploited by approving a large amount of tokens to be spent by the attacker, causing the contract's balance to decrease, and then attempting to spend more tokens than the contract has. This could result in the contract's balance being drained, and the attacker's tokens being lost."
        }
    ]
}