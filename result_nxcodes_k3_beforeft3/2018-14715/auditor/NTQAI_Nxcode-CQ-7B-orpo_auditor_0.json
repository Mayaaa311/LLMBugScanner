{
    "output_list": [
        {
            "function_name": "transfer",
            "code": "function transfer(address _to,uint256 _tokenId) public {
      require(_to != address(0));
      require(_to != address(this));
      require(_owns(msg.sender, _tokenId));
      _transfer(msg.sender, _to, _tokenId);
  }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `transfer` does not check if the `_tokenId` is within the range of the `items` array. If `_tokenId` is greater than or equal to the length of the `items` array, it will cause an integer overflow and potentially lead to unexpected behavior or security vulnerabilities."
        },
        {
            "function_name": "transferFrom",
            "code": "function transferFrom(address _from,address _to,uint256 _tokenId) external {
      require(_to != address(0));
      require(_to != address(this));
      require(_approvedFor(msg.sender, _tokenId));
      require(_owns(_from, _tokenId));
      _transfer(_from, _to, _tokenId);
  }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `transferFrom` does not check if the `_tokenId` is within the range of the `items` array. If `_tokenId` is greater than or equal to the length of the `items` array, it will cause an integer overflow and potentially lead to unexpected behavior or security vulnerabilities."
        },
        {
            "function_name": "mint",
            "code": "function mint(bytes32 _image,address _owner) public onlyOwner returns (uint){
      uint256 newId = _mint(_image);
      _transfer(0, _owner, newId);
      Mint(items[newId].image,tokenIndexToOwner[newId],newId);
      return newId;
  }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `mint` does not check if the `newId` is within the range of the `items` array. If `newId` is greater than or equal to the length of the `items` array, it will cause an integer overflow and potentially lead to unexpected behavior or security vulnerabilities."
        },
        {
            "function_name": "mintBatch",
            "code": "function mintBatch(bytes32 _image1,bytes32 _image2,bytes32 _image3,bytes32 _image4,bytes32 _image5,address _owner) public onlyOwner returns (bool){
      uint256 newId = _mint(_image1);
      _transfer(0, _owner, newId);
      Mint(_image1,tokenIndexToOwner[newId],newId);
      newId=_mint(_image2);
      _transfer(0, _owner, newId);
      Mint(_image2,tokenIndexToOwner[newId],newId);
      newId=_mint(_image3);
      _transfer(0, _owner, newId);
      Mint(_image3,tokenIndexToOwner[newId],newId);
      newId=_mint(_image4);
      _transfer(0, _owner, newId);
      Mint(_image4,tokenIndexToOwner[newId],newId);
      newId=_mint(_image5);
      _transfer(0, _owner, newId);
      Mint(_image5,tokenIndexToOwner[newId],newId);
      return true;
  }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `mintBatch` does not check if the `newId` is within the range of the `items` array. If `newId` is greater than or equal to the length of the `items` array, it will cause an integer overflow and potentially lead to unexpected behavior or security vulnerabilities."
        },
        {
            "function_name": "mintPack",
            "code": "function mintPack(uint256 _price,bytes32 _image1,bytes32 _image2,bytes32 _image3,bytes32 _image4,bytes32 _image5,bytes32 _image6,bytes32 _image7,bytes32 _image8,bytes32 _image9,bytes32 _image10) public onlyOwner returns (bool){
      uint256[10] memory tokens;
      tokens[0] = _mint(_image1);
      tokens[1] = _mint(_image2);
      tokens[2] = _mint(_image3);
      tokens[3] = _mint(_image4);
      tokens[4] = _mint(_image5);
      tokens[5] = _mint(_image6);
      tokens[6] = _mint(_image7);
      tokens[7] = _mint(_image8);
      tokens[8] = _mint(_image9);
      tokens[9] = _mint(_image10);
      Pack memory _pack = Pack({
        tokens: tokens,
        price: _price
      });
      MintPack(packs.push(_pack) - 1, _price,tokens[0],tokens[1],tokens[2],tokens[3],tokens[4],tokens[5],tokens[6],tokens[7],tokens[8],tokens[9]);
      return true;
  }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `mintPack` does not check if the `newId` is within the range of the `items` array. If `newId` is greater than or equal to the length of the `items` array, it will cause an integer overflow and potentially lead to unexpected behavior or security vulnerabilities."
        },
        {
            "function_name": "buyPack",
            "code": "function buyPack(uint256 packId) public payable returns (bool) {
      require( packs[packId].price > 0 );
      require( msg.value >= packs[packId].price );
      packs[packId].price=0;
      for(uint8 i=0;i<10;i++){...}",
            "vulnerability": "Integer Overflow",
            "reason": "The function `buyPack` does not check if the `packId` is within the range of the `packs` array. If `packId` is greater than or equal to the length of the `packs` array, it will cause an integer overflow and potentially lead to unexpected behavior or security vulnerabilities."
        },
        {
            "function_name": "getToken",
            "code": "function getToken(uint256 _id) public view returns (address owner,bytes32 image,uint256 copies) {...}",
            "vulnerability": "Integer Overflow",
            "reason": "The function `getToken` does not check if the `_id` is within the range of the `items` array. If `_id` is greater than or equal to the length of the `items` array, it will cause an integer overflow and potentially lead to unexpected behavior or security vulnerabilities."
        },
        {
            "function_name": "getStack",
            "code": "function getStack(bytes32 _stack) public constant returns (address owner,uint32 block,uint256 token1,uint256 token2,uint256 token3,uint256 token4,uint256 token5) {...}",
            "vulnerability": "Integer Overflow",
            "reason": "The function `getStack` does not check if the `_stack` is within the range of the `stacks` array. If `_stack` is greater than or equal to the length of the `stacks` array, it will cause an integer overflow and potentially lead to unexpected behavior or security vulnerabilities."
        },
        {
            "function_name": "submitStack",
            "code": "function submitStack(uint256 _id,uint256 _id2,uint256 _id3,uint256 _id4,uint256 _id5, bool _public) public returns (bool) {
      require(slammerTime!=address(0));
      require(tokenIndexToOwner[_id]==msg.sender);
      require(tokenIndexToOwner[_id2]==msg.sender);
      require(tokenIndexToOwner[_id3]==msg.sender);
      require(tokenIndexToOwner[_id4]==msg.sender);
      require(tokenIndexToOwner[_id5]==msg.sender);
      require(approve(slammerTime,_id));
      require(approve(slammerTime,_id2));
      require(approve(slammerTime,_id3));
      require(approve(slammerTime,_id4));
      require(approve(slammerTime,_id5));
      bytes32 stack = keccak256(nonce++,msg.sender);
      uint256[5] memory ids = [_id,_id2,_id3,_id4,_id5];
      stacks[stack] = Stack(ids,msg.sender,uint32(block.number));
      SubmitStack(msg.sender,now,stack,_id,_id2,_id3,_id4,_id5,_public);
  }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `submitStack` does not check if the `_id` is within the range of the `items` array. If `_id` is greater than or equal to the length of the `items` array, it will cause an integer overflow and potentially lead to unexpected behavior or security vulnerabilities."
        },
        {
            "function_name": "submitCounterStack",
            "code": "function submitCounterStack(uint256 _id,uint256 _id2,uint256 _id3,uint256 _id4,uint256 _id5, bool _public) public returns (bool) {
      require(slammerTime!=address(0));
      require(tokenIndexToOwner[_id]==msg.sender);
      require(tokenIndexToOwner[_id2]==msg.sender);
      require(tokenIndexToOwner[_id3]==msg.sender);
      require(tokenIndexToOwner[_id4]==msg.sender);
      require(tokenIndexToOwner[_id5]==msg.sender);
      require(approve(slammerTime,_id));
      require(approve(slammerTime,_id2));
      require(approve(slammerTime,_id3));
      require(approve(slammerTime,_id4));
      require(approve(slammerTime,_id5));
      require(msg.sender!=stacks[_stack].owner);
      bytes32 counterstack = keccak256(nonce++,msg.sender,_id);
      uint256[5] memory ids = [_id,_id2,_id3,_id4,_id5];
      stacks[counterstack] = Stack(ids,msg.sender,uint32(block.number));
      stackCounter[counterstack] = _stack;
      CounterStack(msg.sender,now,_stack,counterstack,_id,_id2,_id3,_id4,_id5);
  }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `submitCounterStack` does not check if the `_id` is within the range of the `items` array. If `_id` is greater than or equal to the length of the `items` array, it will cause an integer overflow and potentially lead to unexpected behavior or security vulnerabilities."
        },
        {
            "function_name": "startCoinFlip",
            "code": "function startCoinFlip(bytes32 _stack, bytes32 _counterStack, bytes32 _commit) public returns (bool) {
      require(stacks[_stack].owner==msg.sender);
      require(stackCounter[_counterStack]==_stack);
      require(counterOfStack[_stack]==_counterStack);
      require(mode[_stack]==0);
      commit[_stack]=_commit;
      commitBlock[_stack]=uint32(block.number);
      mode[_stack]=2;
      StartCoinFlip(_stack,_commit);
  }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `startCoinFlip` does not check if the `_stack` is within the range of the `stacks` array. If `_stack` is greater than or equal to the length of the `stacks` array, it will cause an integer overflow and potentially lead to unexpected behavior or security vulnerabilities."
        },
        {
            "function_name": "endCoinFlip",
            "code": "function endCoinFlip(bytes32 _stack, bytes32 _counterStack, bytes32 _reveal) public returns (bool) {
      require(stacks[_stack].owner==msg.sender);
      require(stackCounter[_counterStack]==_stack);
      require(counterOfStack[_stack]==_counterStack);
      require(mode[_stack]==2);
      require(uint32(block.number)>commitBlock[_stack]);
      if(keccak256(_reveal)!=commit[_stack]){...}",
            "vulnerability": "Integer Overflow",
            "reason": "The function `endCoinFlip` does not check if the `_stack` is within the range of the `stacks` array. If `_stack` is greater than or equal to the length of the `stacks` array, it will cause an integer overflow and potentially lead to unexpected behavior or security vulnerabilities."
        },
        {
            "function_name": "raiseSlammer",
            "code": "function raiseSlammer(bytes32 _stack, bytes32 _counterStack, bytes32 _commit) public returns (bool) {
      if(lastActor[_stack]==stacks[_stack].owner){...}",
            "vulnerability": "Integer Overflow",
            "reason": "The function `raiseSlammer` does not check if the `_stack` is within the range of the `stacks` array. If `_stack` is greater than or equal to the length of the `stacks` array, it will cause an integer overflow and potentially lead to unexpected behavior or security vulnerabilities."
        },
        {
            "function_name": "throwSlammer",
            "code": "function throwSlammer(bytes32 _stack, bytes32 _counterStack, bytes32 _reveal) public returns (bool) {
      if(lastActor[_stack]==stacks[_stack].owner){...}",
            "vulnerability": "Integer Overflow",
            "reason": "The function `throwSlammer` does not check if the `_stack` is within the range of the `stacks` array. If `_stack` is greater than or equal to the length of the `stacks` array, it will cause an integer overflow and potentially lead to unexpected behavior or security vulnerabilities."
        },
        {
            "function_name": "drainStack",
            "code": "function drainStack(bytes32 _stack, bytes32 _counterStack) public returns (bool) {
      require( stacks[_stack].owner==msg.sender || stacks[_counterStack].owner==msg.sender );
      require( stackCounter[_counterStack]==_stack );
      require( counterOfStack[_stack]==_counterStack );
      require( lastActor[_stack]==msg.sender );
      require( block.number - lastBlock[_stack] >= TIMEOUTBLOCKS);
      require( mode[_stack]<9 );
      for(uint8 i=0;i<10;i++){...}",
            "vulnerability": "Integer Overflow",
            "reason": "The function `drainStack` does not check if the `_stack` is within the range of the `stacks` array. If `