{
    "output_list": [
        {
            "function_name": "randMod",
            "code": "function randMod(uint256 _modulus) internal returns(uint256) { randNonce++; return uint256(keccak256(randNonce, blockhash(block.number - 1))) % _modulus; }",
            "vulnerability": "Integer Overflow",
            "reason": "The function randMod is using the modulus operator to calculate a random number. However, the modulus operator can cause an integer overflow if the modulus is too small. In this case, the modulus is calculated as randNonce % _modulus, which can cause an integer overflow if randNonce is too large. This can be fixed by using a larger modulus or using a different method to calculate the random number."
        },
        {
            "function_name": "getChampReward",
            "code": "function getChampReward(uint256 _position) public view returns(uint256) { if(_position <= 800){ uint256 rewardPercentage = uint256(2000).sub(2 * (_position - 1)); uint256 availableWithdrawal = address(this).balance.sub(pendingWithdrawal); return availableWithdrawal / 1000000 * rewardPercentage; }else{ return uint256(0); } }",
            "vulnerability": "Integer Overflow",
            "reason": "The function getChampReward is calculating the reward percentage based on the position of the champ. However, the calculation can cause an integer overflow if the position is too large. This can be fixed by using a smaller data type for the position variable or using a different method to calculate the reward percentage."
        },
        {
            "function_name": "getChampReward",
            "code": "function getChampReward(uint256 _position) public view returns(uint256) { if(_position <= 800){ uint256 rewardPercentage = uint256(2000).sub(2 * (_position - 1)); uint256 availableWithdrawal = address(this).balance.sub(pendingWithdrawal); return availableWithdrawal / 1000000 * rewardPercentage; }else{ return uint256(0); } }",
            "vulnerability": "Integer Overflow",
            "reason": "The function getChampReward is calculating the reward percentage based on the position of the champ. However, the calculation can cause an integer overflow if the position is too large. This can be fixed by using a smaller data type for the position variable or using a different method to calculate the reward percentage."
        }
    ]
}