{
    "output_list": [
        {
            "function_name": "balanceOf",
            "code": "function balanceOf(address _owner) public constant returns (uint balance) {
ttif (!created[_owner] && balances[_owner] == 0) {
tttreturn free;
tt} else
tt{
tttreturn balances[_owner];
tt}
t}",
            "vulnerability": "Integer Overflow",
            "reason": "The function balanceOf() is vulnerable to integer overflow. The return value of the function is not checked for overflow. If the balance of an address is greater than the maximum value of uint256, the function will return an incorrect result."
        },
        {
            "function_name": "_transfer",
            "code": "function _transfer(address _from, address _to, uint _value) internal {
ttrequire(_to != 0x0);
ttif (!created[_from]) {
tttbalances[_from] = free;
tttcreated[_from] = true;
tt}
ttif (!created[_to]) {
tttcreated[_to] = true;
tt}
ttrequire(balances[_from] >= _value);
ttrequire(balances[_to] + _value >= balances[_to]);
ttuint previousBalances = balances[_from] + balances[_to];
ttbalances[_from] -= _value;
ttbalances[_to] += _value;
ttemit Transfer(_from, _to, _value);
ttassert(balances[_from] + balances[_to] == previousBalances);
t}",
            "vulnerability": "Integer Overflow",
            "reason": "The function _transfer() is vulnerable to integer overflow. The balances[_from] -= _value; line can cause an integer underflow if _value is greater than the current balance of _from. The balances[_to] += _value; line can cause an integer overflow if the sum of the current balance of _to and _value exceeds the maximum value of uint256."
        },
        {
            "function_name": "balanceOf",
            "code": "function balanceOf(address _owner) public constant returns (uint balance) {
ttif (!created[_owner] && balances[_owner] == 0) {
tttreturn free;
tt} else
tt{
tttreturn balances[_owner];
tt}
t}",
            "vulnerability": "Integer Overflow",
            "reason": "The function balanceOf() is vulnerable to integer overflow. The return value of the function is not checked for overflow. If the balance of an address is greater than the maximum value of uint256, the function will return an incorrect result."
        }
    ]
}