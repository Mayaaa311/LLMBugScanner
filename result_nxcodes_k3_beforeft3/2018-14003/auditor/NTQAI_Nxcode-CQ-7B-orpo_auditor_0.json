{
    "output_list": [
        {
            "function_name": "TokenERC20",
            "code": "function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",
            "vulnerability": "Integer Overflow",
            "reason": "The initialSupply is multiplied by 10 ** uint256(decimals) without checking for overflow. If initialSupply is too large, it may cause an integer overflow and result in an incorrect totalSupply."
        },
        {
            "function_name": "TokenERC20",
            "code": "function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); }",
            "vulnerability": "Integer Overflow",
            "reason": "The balanceOf[_from] -= _value and balanceOf[_to] += _value operations may cause an integer overflow if _value is too large. If _value is greater than the current balance of _from, it may result in a negative balance for _from, and if _value is greater than the maximum possible balance for _to, it may cause an integer overflow."
        },
        {
            "function_name": "TokenERC20",
            "code": "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; }",
            "vulnerability": "Integer Overflow",
            "reason": "The _transfer(_from, _to, _value) operation in the transferFrom function may cause an integer overflow if _value is too large. If _value is greater than the current allowance from _from to msg.sender, it may result in a negative allowance for _from to msg.sender, and if _value is greater than the maximum possible balance for _to, it may cause an integer overflow."
        },
        {
            "function_name": "TokenERC20",
            "code": "function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; }",
            "vulnerability": "Integer Overflow",
            "reason": "The allowance[msg.sender][_spender] = _value operation may cause an integer overflow if _value is too large. If _value is greater than the maximum possible balance for _spender, it may cause an integer overflow."
        },
        {
            "function_name": "TokenERC20",
            "code": "function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; }",
            "vulnerability": "Integer Overflow",
            "reason": "The balanceOf[msg.sender] -= _value and totalSupply -= _value operations may cause an integer overflow if _value is too large. If _value is greater than the current balance of msg.sender, it may result in a negative balance for msg.sender, and if _value is greater than the maximum possible totalSupply, it may cause an integer overflow."
        },
        {
            "function_name": "TokenERC20",
            "code": "function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; }",
            "vulnerability": "Integer Overflow",
            "reason": "The balanceOf[_from] -= _value and totalSupply -= _value operations may cause an integer overflow if _value is too large. If _value is greater than the current balance of _from, it may result in a negative balance for _from, and if _value is greater than the maximum possible totalSupply, it may cause an integer overflow. Additionally, the allowance[_from][msg.sender] -= _value operation may cause an integer overflow if _value is too large."
        },
        {
            "function_name": "WMCToken",
            "code": "function WMCToken(uint256 initialSupply, string tokenName, string tokenSymbol) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}",
            "vulnerability": "Integer Overflow",
            "reason": "The initialSupply is passed to the TokenERC20 constructor without checking for overflow. If initialSupply is too large, it may cause an integer overflow and result in an incorrect totalSupply."
        },
        {
            "function_name": "WMCToken",
            "code": "function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); }",
            "vulnerability": "Integer Overflow",
            "reason": "The balanceOf[_from] -= _value and balanceOf[_to] += _value operations may cause an integer overflow if _value is too large. If _value is greater than the current balance of _from, it may result in a negative balance for _from, and if _value is greater than the maximum possible balance for _to, it may cause an integer overflow."
        },
        {
            "function_name": "WMCToken",
            "code": "function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",
            "vulnerability": "Access Control",
            "reason": "The freezeAccount function is only callable by the contract owner. However, it does not check if the target address is a valid address. If the target address is 0x0, it may cause a revert. Additionally, the function does not check if the target address is already frozen or not. If the target address is already frozen, it may cause a revert."
        },
        {
            "function_name": "WMCToken",
            "code": "function batchTransfer(address[] _receivers, uint256 _value) public { uint cnt = _receivers.length; uint256 amount = uint256(cnt) * _value; require(cnt > 0 && cnt <= 10); require(_value > 0 && balanceOf[msg.sender] >= amount); require(!frozenAccount[msg.sender]); balanceOf[msg.sender] -= amount; for (uint i = 0; i < cnt; i++) { balanceOf[_receivers[i]] += _value; Transfer(msg.sender, _receivers[i], _value); } }",
            "vulnerability": "Integer Overflow",
            "reason": "The balanceOf[msg.sender] -= amount operation may cause an integer overflow if _value is too large. If _value is greater than the current balance of msg.sender, it may result in a negative balance for msg.sender, and if _value is greater than the maximum possible balance for each receiver, it may cause an integer overflow. Additionally, the cnt * _value calculation may cause an integer overflow if cnt is too large."
        }
    ]
}