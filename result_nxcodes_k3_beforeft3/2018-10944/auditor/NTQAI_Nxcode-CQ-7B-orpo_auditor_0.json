{
    "output_list": [
        {
            "function_name": "__callback",
            "code": "function __callback(bytes32 myid, string result) {
    if (msg.sender != oraclize_cbAddress()) {
      throw;
    }
    if(userqueryID[myid]== myid)
    {
       one_ether_usd_price = stringToUint(result);
    valuee(one_ether_usd_price);
    if(one_ether_usd_price<1000)
    {
        one_ether_usd_price = one_ether_usd_price*100;
    }
    else if(one_ether_usd_price<10000)
    {
        one_ether_usd_price = one_ether_usd_price*10;
    }
    valuee(one_ether_usd_price);
            uint no_of_token = (one_ether_usd_price*uservalue[userAddress[myid]])/(275*10000000000000000*100); 
            balances[owner] -= (no_of_token*10000000000);
            balances[userAddress[myid]] += (no_of_token*10000000000);
             Transfer(owner, userAddress[myid] , no_of_token);
              check_array_add(userAddress[myid]);
    }
 }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `__callback` has an integer overflow vulnerability. The variable `no_of_token` is calculated as `(one_ether_usd_price*uservalue[userAddress[myid]])/(275*10000000000000000*100)`. If `one_ether_usd_price` is very large, the calculation may cause an integer overflow. This vulnerability can be exploited by attackers to cause the contract to lose tokens."
        },
        {
            "function_name": "request_dividend",
            "code": "function request_dividend(address token_holder) payable
    {
        holder_token_balance = balanceOf(token_holder)/10000000000;
        Message(holder_token_balance);
        holder_profit = holder_token_balance * profit_per_token;
        Message(holder_profit);
         Transfer(owner, token_holder , (holder_profit/10**18)); 
        token_holder.send(holder_profit);   
    }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `request_dividend` has an integer overflow vulnerability. The variable `holder_profit` is calculated as `holder_token_balance * profit_per_token`. If `holder_token_balance` is very large, the calculation may cause an integer overflow. This vulnerability can be exploited by attackers to cause the contract to lose tokens."
        },
        {
            "function_name": "stringToUint",
            "code": "function stringToUint(string s) returns (uint) {
        bytes memory b = bytes(s);
        uint i;
        uint result1 = 0;
        for (i = 0; i < b.length; i++) {
            uint c = uint(b[i]);
            if(c == 46)
            {
            }
          else if (c >= 48 && c <= 57) {
                result1 = result1 * 10 + (c - 48);
            }
        }
        return result1;
    }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `stringToUint` has an integer overflow vulnerability. The variable `result1` is calculated as `result1 * 10 + (c - 48)`. If the input string `s` is very large, the calculation may cause an integer overflow. This vulnerability can be exploited by attackers to cause the contract to lose tokens."
        }
    ]
}