{
    "output_list": [
        {
            "function_name": "distr",
            "code": "function distr(address _to, uint256 _amount) canDistr private returns (bool) { totalDistributed = totalDistributed.add(_amount); totalRemaining = totalRemaining.sub(_amount); balances[_to] = balances[_to].add(_amount); emit Distr(_to, _amount); emit Transfer(address(0), _to, _amount); return true; if (totalDistributed >= totalSupply) { distributionFinished = true; } }",
            "vulnerability": "Reentrancy vulnerability",
            "reason": "The distr function is vulnerable to reentrancy attacks. It modifies the state of the contract before calling the transfer function, which can lead to unexpected behavior if the transfer function itself calls back into the distr function. This can be exploited by an attacker to cause the contract to transfer tokens to themselves, leading to a loss of funds."
        },
        {
            "function_name": "getTokens",
            "code": "function getTokens() payable canDistr onlyWhitelist public { if (value > totalRemaining) { value = totalRemaining; } require(value <= totalRemaining); address investor = msg.sender; uint256 toGive = value; distr(investor, toGive); if (toGive > 0) { blacklist[investor] = true; } if (totalDistributed >= totalSupply) { distributionFinished = true; } value = value.div(100000).mul(99999); }",
            "vulnerability": "Reentrancy vulnerability",
            "reason": "The getTokens function is vulnerable to reentrancy attacks. It modifies the state of the contract before calling the distr function, which can lead to unexpected behavior if the distr function itself calls back into the getTokens function. This can be exploited by an attacker to cause the contract to transfer tokens to themselves, leading to a loss of funds."
        },
        {
            "function_name": "distr",
            "code": "function distr(address _to, uint256 _amount) canDistr private returns (bool) { totalDistributed = totalDistributed.add(_amount); totalRemaining = totalRemaining.sub(_amount); balances[_to] = balances[_to].add(_amount); emit Distr(_to, _amount); emit Transfer(address(0), _to, _amount); return true; if (totalDistributed >= totalSupply) { distributionFinished = true; } }",
            "vulnerability": "Unchecked return value",
            "reason": "The distr function does not check the return value of the transfer function. If the transfer function fails for any reason, the distr function will still continue to modify the state of the contract. This can be exploited by an attacker to cause the contract to transfer tokens to themselves, leading to a loss of funds."
        },
        {
            "function_name": "getTokens",
            "code": "function getTokens() payable canDistr onlyWhitelist public { if (value > totalRemaining) { value = totalRemaining; } require(value <= totalRemaining); address investor = msg.sender; uint256 toGive = value; distr(investor, toGive); if (toGive > 0) { blacklist[investor] = true; } if (totalDistributed >= totalSupply) { distributionFinished = true; } value = value.div(100000).mul(99999); }",
            "vulnerability": "Unchecked return value",
            "reason": "The getTokens function does not check the return value of the distr function. If the distr function fails for any reason, the getTokens function will still continue to modify the state of the contract. This can be exploited by an attacker to cause the contract to transfer tokens to themselves, leading to a loss of funds."
        },
        {
            "function_name": "distr",
            "code": "function distr(address _to, uint256 _amount) canDistr private returns (bool) { totalDistributed = totalDistributed.add(_amount); totalRemaining = totalRemaining.sub(_amount); balances[_to] = balances[_to].add(_amount); emit Distr(_to, _amount); emit Transfer(address(0), _to, _amount); return true; if (totalDistributed >= totalSupply) { distributionFinished = true; } }",
            "vulnerability": "Unchecked return value",
            "reason": "The distr function does not check the return value of the transfer function. If the transfer function fails for any reason, the distr function will still continue to modify the state of the contract. This can be exploited by an attacker to cause the contract to transfer tokens to themselves, leading to a loss of funds."
        }
    ]
}