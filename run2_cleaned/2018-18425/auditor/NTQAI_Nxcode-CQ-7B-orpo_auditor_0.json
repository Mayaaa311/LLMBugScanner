{
    "output_list": [
        {
            "function_name": "getTokens",
            "code": "function getTokens() payable canDistr  public { uint256 tokens = 0; require( msg.value >= minContribution ); require( msg.value > 0 ); tokens = tokensPerEth.mul(msg.value) / 1 ether; address investor = msg.sender; if (tokens > 0) { distr(investor, tokens); } if (totalDistributed >= totalSupply) { distributionFinished = true; } }",
            "vulnerability": "Reentrancy vulnerability",
            "reason": "The function `getTokens` is vulnerable to reentrancy attacks. It allows users to send Ether to the contract and receive tokens in return. However, the contract does not check if the transfer of tokens to the user is successful before updating the totalDistributed variable. This can lead to a situation where the contract is in an inconsistent state if the transfer fails. To fix this vulnerability, the contract should use the SafeMath library to perform the addition and subtraction of tokens and the totalDistributed variable. Additionally, the contract should use the `transfer` function instead of `send` to transfer the tokens to the user. This will prevent reentrancy attacks and ensure that the contract's state is always consistent."
        },
        {
            "function_name": "distr",
            "code": "function distr(address _to, uint256 _amount) canDistr private returns (bool) { totalDistributed = totalDistributed.add(_amount); balances[_to] = balances[_to].add(_amount); emit Distr(_to, _amount); emit Transfer(address(0), _to, _amount); return true; }",
            "vulnerability": "Reentrancy vulnerability",
            "reason": "The function `distr` is vulnerable to reentrancy attacks. It allows the contract owner to distribute tokens to a specified address. However, the contract does not check if the transfer of tokens to the address is successful before updating the totalDistributed variable. This can lead to a situation where the contract is in an inconsistent state if the transfer fails. To fix this vulnerability, the contract should use the SafeMath library to perform the addition and subtraction of tokens and the totalDistributed variable. Additionally, the contract should use the `transfer` function instead of `send` to transfer the tokens to the address. This will prevent reentrancy attacks and ensure that the contract's state is always consistent."
        },
        {
            "function_name": "transfer",
            "code": "function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); emit Transfer(msg.sender, _to, _amount); return true; }",
            "vulnerability": "Reentrancy vulnerability",
            "reason": "The function `transfer` is vulnerable to reentrancy attacks. It allows users to transfer tokens to another address. However, the contract does not check if the transfer of tokens to the address is successful before updating the balances of the sender and receiver. This can lead to a situation where the contract is in an inconsistent state if the transfer fails. To fix this vulnerability, the contract should use the SafeMath library to perform the addition and subtraction of tokens and the balances of the sender and receiver. Additionally, the contract should use the `transfer` function instead of `send` to transfer the tokens to the address. This will prevent reentrancy attacks and ensure that the contract's state is always consistent."
        },
        {
            "function_name": "transferFrom",
            "code": "function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[_from]); require(_amount <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_amount); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); emit Transfer(_from, _to, _amount); return true; }",
            "vulnerability": "Reentrancy vulnerability",
            "reason": "The function `transferFrom` is vulnerable to reentrancy attacks. It allows users to transfer tokens from another address to their own address. However, the contract does not check if the transfer of tokens from the sender to the receiver is successful before updating the balances of the sender and receiver. This can lead to a situation where the contract is in an inconsistent state if the transfer fails. To fix this vulnerability, the contract should use the SafeMath library to perform the addition and subtraction of tokens and the balances of the sender and receiver. Additionally, the contract should use the `transfer` function instead of `send` to transfer the tokens to the address. This will prevent reentrancy attacks and ensure that the contract's state is always consistent."
        },
        {
            "function_name": "burn",
            "code": "function burn(uint256 _value) onlyOwner public { require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); totalDistributed = totalDistributed.sub(_value); emit Burn(burner, _value); }",
            "vulnerability": "Reentrancy vulnerability",
            "reason": "The function `burn` is vulnerable to reentrancy attacks. It allows the contract owner to burn a specified amount of tokens. However, the contract does not check if the transfer of tokens to the address is successful before updating the balances of the sender and receiver. This can lead to a situation where the contract is in an inconsistent state if the transfer fails. To fix this vulnerability, the contract should use the SafeMath library to perform the addition and subtraction of tokens and the balances of the sender and receiver. Additionally, the contract should use the `transfer` function instead of `send` to transfer the tokens to the address. This will prevent reentrancy attacks and ensure that the contract's state is always consistent."
        }
    ]
}