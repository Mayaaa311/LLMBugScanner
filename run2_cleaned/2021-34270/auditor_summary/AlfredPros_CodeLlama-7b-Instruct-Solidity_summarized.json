 
{
    "output_list": [
        {
            "function_name": "mintToken",
            "code": "function mintToken(address _target, uint256 _mintedAmount) onlyOwner { require (_target != 0x0); balanceOf[_target] += _mintedAmount; _totalSupply += _mintedAmount; Transfer(0, this, _mintedAmount); Transfer(this, _target, _mintedAmount); }",
            "vulnerability": "Unchecked Balance",
            "reason": "The function mintToken does not check if the contract has enough balance to mint the tokens. If the contract does not have enough balance, the transaction will fail. This can be exploited by an attacker who wants to mint more tokens than the contract has. The attacker can send a transaction to mint more tokens than the contract has, and the transaction will fail."
        },
        {
            "function_name": "mine",
            "code": "function mine(address _target, uint256 _minedAmount) onlyDoftManager { require (_minedAmount > 0); require (_target != 0x0); require (miningStorage - _minedAmount >= 0); require (balanceOf[doftManager] >= _minedAmount); require (balanceOf[_target] + _minedAmount > balanceOf[_target]); balanceOf[doftManager] -= _minedAmount; balanceOf[_target] += _minedAmount; miningStorage -= _minedAmount; Mine(_target, _minedAmount); }",
            "vulnerability": "Unchecked Balance",
            "reason": "The function mine does not check if the contract has enough balance to mine the tokens. If the contract does not have enough balance, the transaction will fail. This can be exploited by an attacker who wants to mine more tokens than the contract has. The attacker can send a transaction to mine more tokens than the contract has, and the transaction will fail."
        },
        {
            "function_name": "buy",
            "code": "function buy() payable { require(buyPrice > 0); uint amount = msg.value / buyPrice; _transfer(this, msg.sender, amount); }",
            "vulnerability": "Unchecked Balance",
            "reason": "The function buy does not check if the contract has enough balance to transfer the tokens to the buyer. If the contract does not have enough balance, the transaction will fail. This can be exploited by an attacker who wants to buy more tokens than the contract has. The attacker can send a transaction to buy more tokens than the contract has, and the transaction will fail."
        },
        {
            "function_name": "sell",
            "code": "function sell(uint256 _amount) { require(sellPrice > 0); require(this.balance >= _amount * sellPrice); _transfer(msg.sender, this, _amount); msg.sender.transfer(_amount * sellPrice); }",
            "vulnerability": "Unchecked Balance",
            "reason": "The function sell does not check if the contract has enough balance to transfer the tokens to the seller. If the contract does not have enough balance, the transaction will fail. This can be exploited by an attacker who wants to sell more tokens than the contract has. The attacker can send a transaction to sell more tokens than the contract has, and the transaction will fail."
        },
        {
            "function_name": "transfer",
            "code": "function transfer(address _to, uint _value) returns (bool success) { _transfer(msg.sender, _to, _value); return true; }",
            "vulnerability": "Unchecked Balance",
            "reason": "The function transfer does not check if the contract has enough balance to transfer the tokens to the recipient. If the contract does not have enough balance, the transaction will fail. This can be exploited by an attacker who wants to transfer more tokens than the contract has. The attacker can send a transaction to transfer more tokens than the contract has, and the transaction will fail."
        }
    ]
}