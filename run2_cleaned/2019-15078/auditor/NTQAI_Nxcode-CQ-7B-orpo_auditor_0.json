{
    "output_list": [
        {
            "function_name": "getTokens",
            "code": "function getTokens() payable canDistr onlyWhitelist public { if (value > totalRemaining) { value = totalRemaining; } require(value <= totalRemaining); address investor = msg.sender; uint256 toGive = value; distr(investor, toGive); if (toGive > 0) { blacklist[investor] = true; } if (totalDistributed >= totalSupply) { distributionFinished = true; } value = value.div(100000).mul(99999); }",
            "vulnerability": "Reentrancy Vulnerability",
            "reason": "The function `getTokens` is vulnerable to reentrancy attacks. It allows users to call the `distr` function with a value that is not checked for sufficient balance. This can lead to a reentrancy attack where the `distr` function is called again before the first call has completed, leading to an incorrect balance calculation and potentially loss of funds."
        },
        {
            "function_name": "distr",
            "code": "function distr(address _to, uint256 _amount) canDistr private returns (bool) { totalDistributed = totalDistributed.add(_amount); totalRemaining = totalRemaining.sub(_amount); balances[_to] = balances[_to].add(_amount); emit Distr(_to, _amount); emit Transfer(address(0), _to, _amount); return true; if (totalDistributed >= totalSupply) { distributionFinished = true; } }",
            "vulnerability": "Reentrancy Vulnerability",
            "reason": "The function `distr` is vulnerable to reentrancy attacks. It allows users to call the `distr` function with a value that is not checked for sufficient balance. This can lead to a reentrancy attack where the `distr` function is called again before the first call has completed, leading to an incorrect balance calculation and potentially loss of funds."
        },
        {
            "function_name": "transfer",
            "code": "function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); emit Transfer(msg.sender, _to, _amount); return true; }",
            "vulnerability": "Reentrancy Vulnerability",
            "reason": "The function `transfer` is vulnerable to reentrancy attacks. It allows users to call the `transfer` function with a value that is not checked for sufficient balance. This can lead to a reentrancy attack where the `transfer` function is called again before the first call has completed, leading to an incorrect balance calculation and potentially loss of funds."
        },
        {
            "function_name": "transferFrom",
            "code": "function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[_from]); require(_amount <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_amount); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); emit Transfer(_from, _to, _amount); return true; }",
            "vulnerability": "Reentrancy Vulnerability",
            "reason": "The function `transferFrom` is vulnerable to reentrancy attacks. It allows users to call the `transferFrom` function with a value that is not checked for sufficient balance. This can lead to a reentrancy attack where the `transferFrom` function is called again before the first call has completed, leading to an incorrect balance calculation and potentially loss of funds."
        },
        {
            "function_name": "burn",
            "code": "function burn(uint256 _value) onlyOwner public { require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); totalDistributed = totalDistributed.sub(_value); emit Burn(burner, _value); }",
            "vulnerability": "Reentrancy Vulnerability",
            "reason": "The function `burn` is vulnerable to reentrancy attacks. It allows users to call the `burn` function with a value that is not checked for sufficient balance. This can lead to a reentrancy attack where the `burn` function is called again before the first call has completed, leading to an incorrect balance calculation and potentially loss of funds."
        }
    ]
}