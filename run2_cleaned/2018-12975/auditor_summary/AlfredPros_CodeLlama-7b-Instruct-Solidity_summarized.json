 
{
    "output_list": [
        {
            "function_name": "mint",
            "code": "function mint(address _owner, uint32 _heroClassId) onlyAccessMint public returns (uint256) { require(_owner != address(0)); require(_heroClassId < numberOfHeroClasses); var _heroClassInfo = heroClasses[_heroClassId]; _mint(_owner, numberOfTokenIds); uint32[5] memory _ivForStats; uint32[5] memory _initialStats; for (uint8 i = 0; i < 5; i++) { _ivForStats[i] = (random(_heroClassInfo.maxIVForStats[i] + 1, _heroClassInfo.minIVForStats[i])); _initialStats[i] = _heroClassInfo.baseStats[i] + _ivForStats[i]; } HeroInstance memory _heroInstance = HeroInstance({ heroClassId: _heroClassId, heroName: "", currentLevel: 1, currentExp: 0, lastLocationId: 0, availableAt: now, currentStats: _initialStats, ivForStats: _ivForStats }); tokenIdToHeroInstance[numberOfTokenIds] = _heroInstance; numberOfTokenIds ++; _heroClassInfo.currentNumberOfInstancedHeroes ++; return numberOfTokenIds - 1; }",
            "vulnerability": "Vulnerability: Unchecked return value",
            "reason": "The function mint() calls the internal function _mint() which is not checked for success. If _mint() fails, the transaction will still succeed, but the token will not be minted. This can lead to loss of funds."
        },
        {
            "function_name": "deploy",
            "code": "function deploy(uint256 _tokenId, uint32 _locationId, uint256 _duration) onlyAccessDeploy public returns (bool) { require(ownerOf(_tokenId) != address(0)); var _heroInstance = tokenIdToHeroInstance[_tokenId]; require(_heroInstance.availableAt <= now); _heroInstance.lastLocationId = _locationId; _heroInstance.availableAt = now + _duration; Deploy(msg.sender, _tokenId, _locationId, _duration); }",
            "vulnerability": "Vulnerability: Unchecked return value",
            "reason": "The function deploy() calls the internal function Deploy() which is not checked for success. If Deploy() fails, the transaction will still succeed, but the deployment will not be recorded. This can lead to loss of information."
        },
        {
            "function_name": "addExp",
            "code": "function addExp(uint256 _tokenId, uint32 _exp) onlyAccessDeploy public returns (bool) { require(ownerOf(_tokenId) != address(0)); var _heroInstance = tokenIdToHeroInstance[_tokenId]; var _newExp = _heroInstance.currentExp + _exp; require(_newExp == uint256(uint128(_newExp))); _heroInstance.currentExp += _newExp; }",
            "vulnerability": "Vulnerability: Unchecked return value",
            "reason": "The function addExp() calls the internal function addExp() which is not checked for success. If addExp() fails, the transaction will still succeed, but the experience points will not be added. This can lead to loss of information."
        },
        {
            "function_name": "levelUp",
            "code": "function levelUp(uint256 _tokenId) onlyOwnerOf(_tokenId) whenNotPaused public { var _heroInstance = tokenIdToHeroInstance[_tokenId]; require(_heroInstance.availableAt <= now); var _heroClassInfo = heroClasses[_heroInstance.heroClassId]; require(_heroInstance.currentLevel < _heroClassInfo.maxLevel); var requiredExp = getHeroRequiredExpForLevelUp(_tokenId); require(_heroInstance.currentExp >= requiredExp); var requiredGold = getHeroRequiredGoldForLevelUp(_tokenId); var _ownerOfToken = ownerOf(_tokenId); require(addressToGoldDeposit[_ownerOfToken] >= requiredGold); _heroInstance.currentLevel += 1; for (uint8 i = 0; i < 5; i++) { _heroInstance.currentStats[i] = _heroClassInfo.baseStats[i] + (_heroInstance.currentLevel - 1) * _heroInstance.ivForStats[i]; } _heroInstance.currentExp -= requiredExp; addressToGoldDeposit[_ownerOfToken] -= requiredGold; LevelUp(msg.sender, _tokenId, _heroInstance.currentLevel); }",
            "vulnerability": "Vulnerability: Unchecked return value",
            "reason": "The function levelUp() calls the internal function LevelUp() which is not checked for success. If LevelUp() fails, the transaction will still succeed, but the level up will not be recorded. This can lead to loss of information."
        },
        {
            "function_name": "transferDeposit",
            "code": "function transferDeposit(uint256 _amount) whenNotPaused public { require(goldContract.allowance(msg.sender, this) >= _amount); if (goldContract.transferFrom(msg.sender, this, _amount)) { addressToGoldDeposit[msg.sender] += _amount; } }",
            "vulnerability": "Vulnerability: Unchecked return value",
            "reason": "The function transferDeposit() calls the internal function transferFrom() which is not checked for success. If transferFrom() fails, the transaction will still succeed, but the deposit will not be transferred. This can lead to loss of funds."
        }
    ]
}