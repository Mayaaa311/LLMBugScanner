{
    "output_list": [
        {
            "function_name": "mintTokens",
            "code": "function mintTokens(address _investor) external onlyOwner { balances[_investor] +=  promoValue; totalSupply += promoValue; Transfer(0x0, _investor, promoValue); }",
            "vulnerability": "Vulnerability: Unauthorized minting",
            "reason": "The mintTokens function allows anyone to mint tokens, which is not secure. This can lead to unauthorized token minting and manipulation. The onlyOwner modifier is not used in this function, which means that anyone can mint tokens. This can be exploited by malicious actors to mint more tokens than intended."
        },
        {
            "function_name": "setPromo",
            "code": "function setPromo(uint256 _newValue) external onlyOwner { promoValue = _newValue; }",
            "vulnerability": "Vulnerability: Unauthorized promotion value change",
            "reason": "The setPromo function allows anyone to change the promotion value, which is not secure. This can lead to unauthorized promotion value manipulation. The onlyOwner modifier is not used in this function, which means that anyone can change the promotion value. This can be exploited by malicious actors to manipulate the promotion value and potentially manipulate the token supply."
        },
        {
            "function_name": "transferFrom",
            "code": "function transferFrom(address _from, address _to, uint _amount) public returns (bool) { balances[_from] -= _amount; allowed[_from][msg.sender] -= _amount; balances[_to] -= _amount; Transfer(_from, _to, _amount); return true; }",
            "vulnerability": "Vulnerability: Unauthorized transferFrom",
            "reason": "The transferFrom function allows anyone to transfer tokens from another address, which is not secure. This can lead to unauthorized token transfers. The onlyOwner modifier is not used in this function, which means that anyone can transfer tokens from another address. This can be exploited by malicious actors to transfer tokens from other addresses and potentially manipulate the token supply."
        },
        {
            "function_name": "approve",
            "code": "function approve(address _spender, uint _amount) public returns (bool) { require((_amount == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; }",
            "vulnerability": "Vulnerability: Unauthorized approval",
            "reason": "The approve function allows anyone to approve a spender to transfer tokens on behalf of the owner, which is not secure. This can lead to unauthorized token approvals. The onlyOwner modifier is not used in this function, which means that anyone can approve a spender to transfer tokens on behalf of the owner. This can be exploited by malicious actors to approve a spender to transfer tokens on behalf of the owner and potentially manipulate the token supply."
        },
        {
            "function_name": "allowance",
            "code": "function allowance(address _owner, address _spender) constant returns (uint) { return allowed[_owner][_spender]; }",
            "vulnerability": "Vulnerability: Unauthorized allowance check",
            "reason": "The allowance function allows anyone to check the allowance of a spender for a specific owner, which is not secure. This can lead to unauthorized allowance checks. The onlyOwner modifier is not used in this function, which means that anyone can check the allowance of a spender for a specific owner. This can be exploited by malicious actors to check the allowance of a spender for a specific owner and potentially manipulate the token supply."
        }
    ]
}