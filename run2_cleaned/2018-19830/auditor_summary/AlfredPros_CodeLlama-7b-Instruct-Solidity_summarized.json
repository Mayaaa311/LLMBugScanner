 
{
    "output_list": [
        {
            "function_name": "transfer",
            "code": "function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) unFrozenAccount onlyTransferable { if (frozenAccount[_to]) { InvalidAccount(_to, "The receiver account is frozen"); } else { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); } }",
            "vulnerability": "Frozen Account Vulnerability",
            "reason": "The transfer function checks if the recipient's account is frozen before transferring the tokens. However, it does not handle the case where the sender's account is frozen. This vulnerability allows an attacker to freeze their own account and prevent them from transferring tokens to other accounts."
        },
        {
            "function_name": "transferFrom",
            "code": "function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) unFrozenAccount onlyTransferable{ var _allowance = allowed[_from][msg.sender]; require(!frozenAccount[_from]&&!frozenAccount[_to]); balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); }",
            "vulnerability": "Frozen Account Vulnerability",
            "reason": "The transferFrom function checks if both the sender's and recipient's accounts are frozen before transferring the tokens. However, it does not handle the case where the sender's account is frozen. This vulnerability allows an attacker to freeze their own account and prevent them from transferring tokens to other accounts."
        },
        {
            "function_name": "switchLiquidity",
            "code": "function switchLiquidity (bool _transferable) onlyOwner returns (bool success) { transferable=_transferable; return true; }",
            "vulnerability": "Liquidity Switching Vulnerability",
            "reason": "The switchLiquidity function allows the owner to switch the liquidity status of the token. However, it does not handle the case where the liquidity is switched off. This vulnerability allows an attacker to disable the liquidity and prevent them from transferring tokens to other accounts."
        },
        {
            "function_name": "liquidityStatus",
            "code": "function liquidityStatus () view returns (bool _transferable) { return transferable; }",
            "vulnerability": "Liquidity Switching Vulnerability",
            "reason": "The liquidityStatus function allows anyone to check the liquidity status of the token. However, it does not handle the case where the liquidity is switched off. This vulnerability allows an attacker to check the liquidity status and disable the liquidity if they want to."
        },
        {
            "function_name": "freezeAccount",
            "code": "function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target]=freeze; FrozenFunds(target, freeze); }",
            "vulnerability": "Frozen Account Vulnerability",
            "reason": "The freezeAccount function allows the owner to freeze or unfreeze an account. However, it does not handle the case where the account is already frozen or unfreeze. This vulnerability allows an attacker to freeze their own account and prevent them from transferring tokens to other accounts."
        }
    ]
}