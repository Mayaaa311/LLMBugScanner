<bos>Q: You are a smart contract auditor, identify and explain severe vulnerabilities in the provided smart contract. Make sure that they are exploitable in real world and beneficial to attackers. Provide each identified vulnerability with intermediate reasoning and its associated function. Remember, you must provide the entire function code and do not use "...". Make your reasoning comprehensive and detailed. Smart contract code:\npragma solidity ^0.4.16;\ncontract EAI_TokenERC {\n    string public name;\n    string public symbol;\n    uint8 public decimals = 8;\n    uint256 public totalSupply;\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event Burn(address indexed from, uint256 value);\n    function EAI_TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  \n        balanceOf[msg.sender] = totalSupply;                \n        name = tokenName;                                   \n        symbol = tokenSymbol;                               \n    }\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(_to != 0x0);\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     \n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n    function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);   \n        balanceOf[msg.sender] -= _value;            \n        totalSupply -= _value;                      \n        emit Burn(msg.sender, _value);\n        return true;\n    }\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);                \n        require(_value <= allowance[_from][msg.sender]);    \n        balanceOf[_from] -= _value;                         \n        allowance[_from][msg.sender] -= _value;             \n        totalSupply -= _value;                              \n        emit Burn(_from, _value);\n        return true;\n    }\n}\n\\nYou should only output in below json format(stop when you finished the json):\n{\n    "output_list": [\n        {\n            "function_name": "<function_name_1>",\n            "code": "<code of the function1>",\n            "vulnerability": "<short_vulnera_desc_1>",\n            "reason": "<reason_1>"\n        },\n        {\n            "function_name": "<function_name_2>",\n            "code": "<code of the function2>",\n            "vulnerability": "<short_vulnera_desc_2>",\n            "reason": "<reason_2>"\n        }\n    ]\n}\n\nOutput 5 most severe vulnerabilities(they should not be the same bug)\nIf no vulnerability is detected, you should only output in this json format {"output_list": []}.\\n\n\nA: 1. You should only output in below json format(stop when you finished the json):\n{\n    "output_list": [\n        {\n            "function_name": "<function_name_1>",\n            "code": "<code of the function1>",\n            "vulnerability": "<short_vulnera_desc_1>",\n            "reason": "<reason_1>"\n        },\n        {\n            "function_name