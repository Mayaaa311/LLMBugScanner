{
    "output_list": [
        {
            "function_name": "transfer",
            "code": "function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {\n        require(_to != address(0));\n        require(_amount <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }",
            "vulnerability": "Reentrancy",
            "reason": "The function transfer is vulnerable to reentrancy attacks. An attacker can call the transfer function multiple times in a row, causing the contract to execute the function multiple times, leading to a loss of funds."
        },
        {
            "function_name": "transferFrom",
            "code": "function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {\n        require(_to != address(0));\n        require(_amount <= balances[_from]);\n        require(_amount <= allowed[_from][msg.sender]);\n        balances[_from] = balances[_from].sub(_amount);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }",
            "vulnerability": "Reentrancy",
            "reason": "The function transferFrom is vulnerable to reentrancy attacks. An attacker can call the transferFrom function multiple times in a row, causing the contract to execute the function multiple times, leading to a loss of funds."
        },
        {
            "function_name": "getTokenBalance",
            "code": "function getTokenBalance(address tokenAddress, address who) constant public returns (uint){\n        AltcoinToken t = AltcoinToken(tokenAddress);\n        uint bal = t.balanceOf(who);\n        return bal;\n    }",
            "vulnerability": "Denial of Service",
            "reason": "The function getTokenBalance can cause a Denial of Service attack if the token contract is down or not responding. This can lead to the contract being unable to execute the function and potentially locking up the contract."
        },
        {
            "function_name": "withdrawAltcoinTokens",
            "code": "function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {\n        AltcoinToken token = AltcoinToken(_tokenContract);\n        uint256 amount = token.balanceOf(address(this));\n        return token.transfer(owner, amount);\n    }",
            "vulnerability": "Denial of Service",
            "reason": "The function withdrawAltcoinTokens can cause a Denial of Service attack if the token contract is down or not responding. This can lead to the contract being unable to execute the function and potentially lock up the contract."
        },
        {
            "function_name": "getTokens",
            "code": "function () external payable {\n        getTokens();\n     }\n    function getTokens() payable canDistr  public {\n        uint256 tokens = 0;\n        require( msg.value >= minContribution );\n        require( msg.value > 0 );\n        tokens = tokensPerEth.mul(msg.value) / 1 ether;        \n        address investor = msg.sender;\n        if (tokens > 0) {\n            distr(investor, tokens);\n        }\n        if (totalDistributed >= totalSupply) {\n            distributionFinished = true;\n        }\n    }",
            "vulnerability": "Denial of Service",
            "reason": "The function getTokens can cause a Denial of Service attack if the contract is unable to receive Ether. This can lead to the contract being unable to receive Ether and potentially lock up the contract."
        }
    ]
}