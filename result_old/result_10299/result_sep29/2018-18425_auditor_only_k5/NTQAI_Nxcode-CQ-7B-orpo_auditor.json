{
    "output_list": [
        {
            "function_name": "getTokens",
            "code": "function getTokens() payable canDistr  public {\n    uint256 tokens = 0;\n    require( msg.value >= minContribution );\n    require( msg.value > 0 );\n    tokens = tokensPerEth.mul(msg.value) / 1 ether;        \n    address investor = msg.sender;\n    if (tokens > 0) {\n        distr(investor, tokens);\n    }\n    if (totalDistributed >= totalSupply) {\n        distributionFinished = true;\n    }\n}",
            "vulnerability": "Reentrancy vulnerability",
            "reason": "The `getTokens` function is vulnerable to reentrancy attacks. When the function is called, it sends tokens to the investor and updates the total distributed amount. However, the function does not check if the tokens were successfully transferred before updating the total distributed amount. This can lead to a reentrancy attack where the attacker can call the `getTokens` function again, causing the tokens to be transferred again, leading to a loss of funds for the attacker."
        },
        {
            "function_name": "distr",
            "code": "function distr(address _to, uint256 _amount) canDistr private returns (bool) {\n    totalDistributed = totalDistributed.add(_amount);        \n    balances[_to] = balances[_to].add(_amount);\n    emit Distr(_to, _amount);\n    emit Transfer(address(0), _to, _amount);\n    return true;\n}",
            "vulnerability": "Reentrancy vulnerability",
            "reason": "The `distr` function is vulnerable to reentrancy attacks. When the function is called, it updates the total distributed amount and the balance of the recipient address. However, the function does not check if the tokens were successfully transferred before updating the total distributed amount. This can lead to a reentrancy attack where the attacker can call the `distr` function again, causing the tokens to be transferred again, leading to a loss of funds for the attacker."
        },
        {
            "function_name": "adminClaimAirdrop",
            "code": "function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        \n    doAirdrop(_participant, _amount);\n}",
            "vulnerability": "Reentrancy vulnerability",
            "reason": "The `adminClaimAirdrop` function is vulnerable to reentrancy attacks. When the function is called, it calls the `doAirdrop` function to distribute tokens to the participant. However, the `doAirdrop` function does not check if the tokens were successfully transferred before updating the total distributed amount. This can lead to a reentrancy attack where the attacker can call the `adminClaimAirdrop` function again, causing the tokens to be transferred again, leading to a loss of funds for the attacker."
        },
        {
            "function_name": "adminClaimAirdropMultiple",
            "code": "function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        \n    for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);\n}",
            "vulnerability": "Reentrancy vulnerability",
            "reason": "The `adminClaimAirdropMultiple` function is vulnerable to reentrancy attacks. When the function is called, it calls the `doAirdrop` function to distribute tokens to multiple participants. However, the `doAirdrop` function does not check if the tokens were successfully transferred before updating the total distributed amount. This can lead to a reentrancy attack where the attacker can call the `adminClaimAirdropMultiple` function again, causing the tokens to be transferred again, leading to a loss of funds for the attacker."
        },
        {
            "function_name": "burn",
            "code": "function burn(uint256 _value) onlyOwner public {\n    require(_value <= balances[msg.sender]);\n    address burner = msg.sender;\n    balances[burner] = balances[burner].sub(_value);\n    totalSupply = totalSupply.sub(_value);\n    totalDistributed = totalDistributed.sub(_value);\n    emit Burn(burner, _value);\n}",
            "vulnerability": "Reentrancy vulnerability",
            "reason": "The `burn` function is vulnerable to reentrancy attacks. When the function is called, it burns the specified amount of tokens from the sender's balance and updates the total supply and total distributed amount. However, the function does not check if the tokens were successfully burned before updating the total supply and total distributed amount. This can lead to a reentrancy attack where the attacker can call the `burn` function again, causing the tokens to be burned again, leading to a loss of funds for the attacker."
        }
    ]
}