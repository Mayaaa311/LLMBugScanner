<file_sep><fim_prefix>const ethers = require('ethers');
const { abi } = require('./build/contracts/BecToken.json');
// const provider = new ethers.providers.JsonRpcProvider(); // ganache
const provider = new ethers.providers.JsonRpcProvider("https://bsc-dataseed1.binance.org/"); // mainnet
const interfa<fim_suffix>.address);
  return contract;
}

<fim_middle>ce = new ethers.utils.Interface(abi);
// const privateKey = "0x3d21d59387f4619c67b6a2d76e174ed7e1395719f270a76769b72a3500e6d524"; // ganache
const privateKey = process.argv[2];
// const wallet = new ethers.Wallet(privateKey);
const wallet = new ethers.Wallet(privateKey, provider);

// const address = "0x5c52C9b38c1766a848E4B00c19dF8C4bDeC5F071"; // ganache
const address = process.argv[3];

async function run(address, privateKey) {
  const contract = await deployContract(wallet);

  const transaction = {
    gasLimit: 2100000, 
    gasPrice: ethers.utils.parseUnits('0', 'gwei'),
  };
  
  let signedTransaction; 
  if (privateKey) {
    signedTransaction = await wallet.signTransaction({ ...transaction, to: contract.address });
  } else {
    const estimateGas = await provider.estimateGas(transaction);
    const gasPrice = ethers.utils.parseUnits('1', 'gwei');

    const txCount = await provider.getTransactionCount(wallet.address);
    
    signedTransaction = wallet.signTransaction({
      ...transaction, 
      to: contract.address,
      nonce: txCount,
      gasLimit: estimateGas,
      gasPrice,
    });
  }

  let receipt; 
  try {
    console.log('sending transaction...'); 
    receipt = await provider.sendTransaction(signedTransaction);
    console.log(`receipt.blockHash ${receipt.blockHash}`);
  } catch (e) {
    if (!privateKey || e.message !== 'processing response error: invalid argument 0: json: cannot unmarshal hex number with leading zero into Go value of type common.Address') {
      throw e; 
    } else {
      console.log('cannot send transaction, not enough BNB');
    }
  }

  // console.log(`receipt ${JSON.stringify(receipt)}`);
}
run();

async function deployContract(wallet) {
  const contractFactory = new ethers.ContractFactory(abi, wallet);
  
  // ganache
  // const address = "0x5c52C9b38c1766a848E4B00c19dF8C4bDeC5F071"; 
  // const privateKey = "";

  const contract = await contractFactory.deploy();
  
  console.log('transaction sent');
  let receipt; 
  while (true) {
    try {
      receipt = await provider.getTransactionReceipt(contract.address);
      break; 
    } catch (e) {}
    
    console.log(`waiting for transaction to be mined ${new Date().toLocaleString()}`);
    await new Promise(r => setTimeout(r, 10 * 1000)); 
  }

  if (!receipt.status || !receipt.contractAddress) {
    throw Error('deploy failed');
  }
  
  console.log(`deployed contract address ${receipt.contractAddress}`)
  console.log(`${address}`);

  // return await new ethers.Contract(address, abi, wallet);
  return new ethers.Contract(address, abi, provider<file_sep><fim_prefix><fim_suffix>hain
<fim_middle># BecToken-BSC
Beauty C