 
{
    "output_list": [
        {
            "function_name": "transfer",
            "code": "function transfer(address _to, uint256 _value) { if (balanceOf[msg.sender] < _value) throw; if (balanceOf[_to] + _value < balanceOf[_to]) throw; balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; Transfer(msg.sender, _to, _value); }",
            "vulnerability": "Integer Overflow",
            "reason": "The transfer function does not check if the recipient's balance will overflow. If the recipient's balance is greater than the maximum possible value for a uint256, the transfer will fail and the sender's balance will be reduced by the amount that failed to be transferred. This can be exploited by a malicious contract that sends a large amount of tokens to the contract, then the contract attempts to transfer the tokens to a recipient with a balance that is close to the maximum possible value for a uint256. The transfer will fail, but the contract will still attempt to transfer the tokens to the recipient, which will result in the contract's balance being reduced by the amount that failed to be transferred. This can be used to steal tokens from the contract."
        },
        {
            "function_name": "transferFrom",
            "code": "function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balanceOf[_from] < _value) throw; if (balanceOf[_to] + _value < balanceOf[_to]) throw; if (_value > allowance[_from][msg.sender]) throw; balanceOf[_from] -= _value; balanceOf[_to] += _value; allowance[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; }",
            "vulnerability": "Integer Overflow",
            "reason": "The transferFrom function does not check if the recipient's balance will overflow. If the recipient's balance is greater than the maximum possible value for a uint256, the transfer will fail and the sender's balance will be reduced by the amount that failed to be transferred. This can be exploited by a malicious contract that sends a large amount of tokens to the contract, then the contract attempts to transfer the tokens to a recipient with a balance that is close to the maximum possible value for a uint256. The transfer will fail, but the contract will still attempt to transfer the tokens to the recipient, which will result in the contract's balance being reduced by the amount that failed to be transferred. This can be used to steal tokens from the contract."
        },
        {
            "function_name": "buy",
            "code": "function buy() payable { if(isSelling == false) throw; uint amount = msg.value * buyRate; balanceOf[msg.sender] += amount; balanceOf[this] -= amount; Transfer(this, msg.sender, amount); }",
            "vulnerability": "Integer Overflow",
            "reason": "The buy function does not check if the recipient's balance will overflow. If the recipient's balance is greater than the maximum possible value for a uint256, the buy will fail and the contract's balance will be reduced by the amount that failed to be transferred. This can be exploited by a malicious contract that sends a large amount of ether to the contract, then the contract attempts to buy tokens with a price that is close to the maximum possible value for a uint256. The buy will fail, but the contract will still attempt to buy tokens, which will result in the contract's balance being reduced by the amount that failed to be transferred. This can be used to steal tokens from the contract."
        },
        {
            "function_name": "mintToken",
            "code": "function mintToken(address target, uint256 mintedAmount) onlyOwner { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; Transfer(0, this, mintedAmount); Transfer(this, target, mintedAmount); }",
            "vulnerability": "Integer Overflow",
            "reason": "The mintToken function does not check if the recipient's balance will overflow. If the recipient's balance is greater than the maximum possible value for a uint256, the mintToken will fail and the contract's total supply will be reduced by the amount that failed to be minted. This can be exploited by a malicious contract that sends a large amount of tokens to the contract, then the contract attempts to mint tokens to a recipient with a balance that is close to the maximum possible value for a uint256. The mintToken will fail, but the contract will still attempt to mint tokens, which will result in the contract's total supply being reduced by the amount that failed to be minted. This can be used to steal tokens from the contract."
        },
        {
            "function_name": "withdrawToOwner",
            "code": "function withdrawToOwner(uint256 amountWei) onlyOwner { owner.transfer(amountWei); }",
            "vulnerability": "Access Control",
            "reason": "The withdrawToOwner function does not check if the sender is the owner. If the sender is not the owner, the function will fail and the funds will remain in the contract. This can be exploited by a malicious contract that sends a large amount of ether to the contract, then the contract attempts to withdraw the funds to a recipient with a balance that is close to the maximum possible value for a uint256. The withdrawal will fail, but the contract will still attempt to withdraw the funds, which will result in the contract's balance being reduced by the amount that failed to be withdrawn. This can be used to steal ether from the contract."
        }
    ]
}