{
    "output_list": [
        {
            "function_name": "__callback",
            "code": "function __callback(bytes32 myid, string result) {
    if (msg.sender != oraclize_cbAddress()) {
      throw;
    }
    if(userqueryID[myid]== myid)
    {
       one_ether_usd_price = stringToUint(result);
    valuee(one_ether_usd_price);
    if(one_ether_usd_price<1000)
    {
        one_ether_usd_price = one_ether_usd_price*100;
    }
    else if(one_ether_usd_price<10000)
    {
        one_ether_usd_price = one_ether_usd_price*10;
    }
    valuee(one_ether_usd_price);
            uint no_of_token = (one_ether_usd_price*uservalue[userAddress[myid]])/(275*10000000000000000*100); 
            balances[owner] -= (no_of_token*10000000000);
            balances[userAddress[myid]] += (no_of_token*10000000000);
             Transfer(owner, userAddress[myid] , no_of_token);
              check_array_add(userAddress[myid]);
    }
 }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `__callback` has an integer overflow vulnerability. The variable `no_of_token` is calculated as `(one_ether_usd_price*uservalue[userAddress[myid]])/(275*10000000000000000*100)`. If `one_ether_usd_price` is very large, the calculation may result in an integer overflow. This can lead to incorrect results and potentially loss of funds."
        },
        {
            "function_name": "stringToUint",
            "code": "function stringToUint(string s) returns (uint) {
        bytes memory b = bytes(s);
        uint i;
        uint result1 = 0;
        for (i = 0; i < b.length; i++) {
            uint c = uint(b[i]);
            if(c == 46)
            {
            }
          else if (c >= 48 && c <= 57) {
                result1 = result1 * 10 + (c - 48);
            }
        }
        return result1;
    }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `stringToUint` has an integer overflow vulnerability. The variable `result1` is calculated as `result1 * 10 + (c - 48)`. If the input string `s` is very large, the calculation may result in an integer overflow. This can lead to incorrect results and potentially loss of funds."
        },
        {
            "function_name": "convert",
            "code": "function convert(uint _value) returns (bool ok)
     {
         return true;
     }",
            "vulnerability": "Wrong Logic",
            "reason": "The function `convert` has a wrong logic vulnerability. The function always returns `true`, which is not a correct implementation of the `convert` function. The `convert` function should convert the input value to a different currency or token, but it currently does not do anything. This can lead to incorrect results and potentially loss of funds."
        },
        {
            "function_name": "drain",
            "code": "function drain() onlyOwner {
ttif (!owner.send(this.balance)) throw;
t}",
            "vulnerability": "Access Control",
            "reason": "The function `drain` has an access control vulnerability. The function is only callable by the owner of the contract. However, it does not check whether the owner has sufficient balance to send. If the owner does not have sufficient balance, the function will fail and the funds will be lost. This can lead to loss of funds."
        },
        {
            "function_name": "transfer_ownership",
            "code": "function transfer_ownership(address to) onlyOwner {
        if (msg.sender != owner) throw;
        owner = to;
         balances[owner]=balances[msg.sender];
         balances[msg.sender]=0;
    }",
            "vulnerability": "Access Control",
            "reason": "The function `transfer_ownership` has an access control vulnerability. The function is only callable by the owner of the contract. However, it does not check whether the new owner has sufficient balance to receive. If the new owner does not have sufficient balance, the function will fail and the funds will be lost. This can lead to loss of funds."
        }
    ]
}