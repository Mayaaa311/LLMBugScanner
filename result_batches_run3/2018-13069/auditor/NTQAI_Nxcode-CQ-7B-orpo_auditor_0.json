{
    "output_list": [
        {
            "function_name": "TokenERC20",
            "code": "function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; }",
            "vulnerability": "Integer Overflow",
            "reason": "The initialSupply is multiplied by 10^18, which could potentially cause an integer overflow if the initialSupply is too large. This could lead to the totalSupply being less than the actual amount of tokens created, which could be exploited by attackers."
        },
        {
            "function_name": "TokenERC20",
            "code": "function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",
            "vulnerability": "Integer Overflow",
            "reason": "The balanceOf[_from] -= _value; line could potentially cause an integer overflow if the _value is too large. This could lead to the balanceOf[_from] being less than the actual amount of tokens transferred, which could be exploited by attackers."
        },
        {
            "function_name": "TokenERC20",
            "code": "function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",
            "vulnerability": "Integer Overflow",
            "reason": "The balanceOf[_to] += _value; line could potentially cause an integer overflow if the _value is too large. This could lead to the balanceOf[_to] being less than the actual amount of tokens transferred, which could be exploited by attackers."
        },
        {
            "function_name": "TokenERC20",
            "code": "function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",
            "vulnerability": "Integer Overflow",
            "reason": "The previousBalances = balanceOf[_from] + balanceOf[_to]; line could potentially cause an integer overflow if the balanceOf[_from] or balanceOf[_to] is too large. This could lead to the previousBalances being less than the actual amount of tokens transferred, which could be exploited by attackers."
        },
        {
            "function_name": "TokenERC20",
            "code": "function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",
            "vulnerability": "Integer Overflow",
            "reason": "The balanceOf[_from] -= _value; line could potentially cause an integer overflow if the _value is too large. This could lead to the balanceOf[_from] being less than the actual amount of tokens transferred, which could be exploited by attackers."
        }
    ]
}