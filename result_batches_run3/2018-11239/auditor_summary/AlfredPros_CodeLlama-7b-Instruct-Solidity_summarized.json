 
{
    "output_list": [
        {
            "function_name": "burn",
            "code": "function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; balanceOf[0x0] += _value; currentSupply -= _value; Burn(msg.sender, _value); return true; }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `burn` allows users to burn their tokens. However, it does not check if the resulting balance of the sender after burning exceeds the maximum possible value for a uint256. This could lead to an integer overflow, where the sender's balance becomes larger than the maximum possible value for a uint256. This could be exploited by an attacker to steal all the tokens from the sender."
        },
        {
            "function_name": "_transfer",
            "code": "function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value + burnPerTransaction); require (balanceOf[_to] + _value > balanceOf[_to]); balanceOf[_from] -= _value + burnPerTransaction; balanceOf[_to] += _value; balanceOf[0x0] += burnPerTransaction; currentSupply -= burnPerTransaction; Burn(_from, burnPerTransaction); Transfer(_from, _to, _value); }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `_transfer` is called by `transfer` and `transferFrom` to transfer tokens from one address to another. However, it does not check if the resulting balance of the recipient after receiving the tokens exceeds the maximum possible value for a uint256. This could lead to an integer overflow, where the recipient's balance becomes larger than the maximum possible value for a uint256. This could be exploited by an attacker to steal all the tokens from the recipient."
        },
        {
            "function_name": "burn",
            "code": "function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; balanceOf[0x0] += _value; currentSupply -= _value; Burn(msg.sender, _value); return true; }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `burn` allows users to burn their tokens. However, it does not check if the resulting balance of the contract after burning exceeds the maximum possible value for a uint256. This could lead to an integer overflow, where the contract's balance becomes larger than the maximum possible value for a uint256. This could be exploited by an attacker to steal all the tokens from the contract."
        },
        {
            "function_name": "burn",
            "code": "function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; balanceOf[0x0] += _value; currentSupply -= _value; Burn(msg.sender, _value); return true; }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `burn` allows users to burn their tokens. However, it does not check if the resulting balance of the sender after burning exceeds the maximum possible value for a uint256. This could lead to an integer overflow, where the sender's balance becomes larger than the maximum possible value for a uint256. This could be exploited by an attacker to steal all the tokens from the sender."
        },
        {
            "function_name": "burn",
            "code": "function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; balanceOf[0x0] += _value; currentSupply -= _value; Burn(msg.sender, _value); return true; }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `burn` allows users to burn their tokens. However, it does not check if the resulting balance of the contract after burning exceeds the maximum possible value for a uint256. This could lead to an integer overflow, where the contract's balance becomes larger than the maximum possible value for a uint256. This could be exploited by an attacker to steal all the tokens from the contract."
        }
    ]
}