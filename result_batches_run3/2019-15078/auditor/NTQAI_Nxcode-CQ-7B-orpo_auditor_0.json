{
    "output_list": [
        {
            "function_name": "getTokens",
            "code": "function getTokens() payable canDistr onlyWhitelist public { if (value > totalRemaining) { value = totalRemaining; } require(value <= totalRemaining); address investor = msg.sender; uint256 toGive = value; distr(investor, toGive); if (toGive > 0) { blacklist[investor] = true; } if (totalDistributed >= totalSupply) { distributionFinished = true; } value = value.div(100000).mul(99999); }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `getTokens` allows users to purchase tokens with a value that is greater than the remaining supply. This can lead to integer overflow, where the value is increased beyond the maximum value that can be stored in a uint256 variable. This can result in the contract's total supply being incorrectly reduced, potentially leading to loss of funds for the contract owner."
        },
        {
            "function_name": "distr",
            "code": "function distr(address _to, uint256 _amount) canDistr private returns (bool) { totalDistributed = totalDistributed.add(_amount); totalRemaining = totalRemaining.sub(_amount); balances[_to] = balances[_to].add(_amount); emit Distr(_to, _amount); emit Transfer(address(0), _to, _amount); return true; if (totalDistributed >= totalSupply) { distributionFinished = true; } }",
            "vulnerability": "Integer Overflow",
            "reason": "The function `distr` allows the contract owner to distribute tokens to an address. However, it does not check if the distribution would result in an integer overflow. If the total distributed amount is greater than the maximum value that can be stored in a uint256 variable, this can lead to incorrectly reducing the contract's total supply, potentially leading to loss of funds for the contract owner."
        },
        {
            "function_name": "getTokens",
            "code": "function getTokens() payable canDistr onlyWhitelist public { if (value > totalRemaining) { value = totalRemaining; } require(value <= totalRemaining); address investor = msg.sender; uint256 toGive = value; distr(investor, toGive); if (toGive > 0) { blacklist[investor] = true; } if (totalDistributed >= totalSupply) { distributionFinished = true; } value = value.div(100000).mul(99999); }",
            "vulnerability": "Access Control",
            "reason": "The function `getTokens` is only accessible to whitelisted addresses and can be called by anyone. This can lead to unauthorized access to the contract's distribution mechanism, potentially leading to loss of funds for the contract owner."
        },
        {
            "function_name": "getTokens",
            "code": "function getTokens() payable canDistr onlyWhitelist public { if (value > totalRemaining) { value = totalRemaining; } require(value <= totalRemaining); address investor = msg.sender; uint256 toGive = value; distr(investor, toGive); if (toGive > 0) { blacklist[investor] = true; } if (totalDistributed >= totalSupply) { distributionFinished = true; } value = value.div(100000).mul(99999); }",
            "vulnerability": "Typo Constructor",
            "reason": "The function `getTokens` has a typo in its name. The correct name should be `getTokens`, but it is currently named `getTokens`. This typo can lead to confusion and potential errors in the contract's implementation."
        },
        {
            "function_name": "getTokens",
            "code": "function getTokens() payable canDistr onlyWhitelist public { if (value > totalRemaining) { value = totalRemaining; } require(value <= totalRemaining); address investor = msg.sender; uint256 toGive = value; distr(investor, toGive); if (toGive > 0) { blacklist[investor] = true; } if (totalDistributed >= totalSupply) { distributionFinished = true; } value = value.div(100000).mul(99999); }",
            "vulnerability": "Bad Randomness",
            "reason": "The function `getTokens` uses a fixed value for the `value` variable, which is then used to determine the amount of tokens to distribute to the investor. This can lead to predictable distribution patterns, potentially leading to loss of funds for the contract owner."
        }
    ]
}