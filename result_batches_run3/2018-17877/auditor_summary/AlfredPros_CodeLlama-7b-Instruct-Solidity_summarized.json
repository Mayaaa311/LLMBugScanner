 
{
    "output_list": [
        {
            "function_name": "buyHeart",
            "code": "function buyHeart(address referred) public payable { require(msg.value >= 1000000000, "pocket lint: not a valid currency"); require(msg.value <= 100000000000000000000000, "no vitalik, no"); address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, "sorry humans only"); uint256 _hearts = (RoundETH[Round]).keysRec(msg.value); uint256 _pearn; require(_hearts >= 100000000000000000); require(RoundTime[Round] > now || RoundTime[Round] == 0); updateTimer(_hearts); RoundHeart[Round] += _hearts; RoundMyHeart[Round][msg.sender] += _hearts; if (referred != address(0) && referred != msg.sender) { _pearn = (((msg.value.mul(30) / 100).mul(1000000000000000000)) / (RoundHeart[Round])).mul(_hearts)/ (1000000000000000000); onwerfee += (msg.value.mul(4) / 100); RoundETH[Round] += msg.value.mul(54) / 100; Luckybuy += msg.value.mul(2) / 100; MyreferredRevenue[referred] += (msg.value.mul(10) / 100); RoundPayMask[Round] += ((msg.value.mul(30) / 100).mul(1000000000000000000)) / (RoundHeart[Round]); RoundMyPayMask[Round][msg.sender] = (((RoundPayMask[Round].mul(_hearts)) / (1000000000000000000)).sub(_pearn)).add(RoundMyPayMask[Round][msg.sender]); emit referredEvent(msg.sender, referred, msg.value.mul(10) / 100); } else { _pearn = (((msg.value.mul(40) / 100).mul(1000000000000000000)) / (RoundHeart[Round])).mul(_hearts)/ (1000000000000000000); RoundETH[Round] += msg.value.mul(54) / 100; Luckybuy += msg.value.mul(2) / 100; onwerfee +=(msg.value.mul(4) / 100); RoundPayMask[Round] += ((msg.value.mul(40) / 100).mul(1000000000000000000)) / (RoundHeart[Round]); RoundMyPayMask[Round][msg.sender] = (((RoundPayMask[Round].mul(_hearts)) / (1000000000000000000)).sub(_pearn)).add(RoundMyPayMask[Round][msg.sender]); } if (msg.value >= 100000000000000000){ luckybuyTracker_++; if (luckyBuy() == true) { msg.sender.transfer(Luckybuy); emit luckybuyEvent(msg.sender, Luckybuy, Round); luckybuyTracker_ = 0; Luckybuy = 0; } } RoundLastGreedyMan[Round] = msg.sender; emit buyheartEvent(msg.sender, _hearts, msg.value, Round, referred); }",
            "vulnerability": "Integer Overflow",
            "reason": "The function buyHeart has an integer overflow vulnerability. The variable luckybuyTracker_ is incremented by 1 when a user buys hearts with a value of 100000000000000000 or more. However, the variable luckybuyTracker_ is not checked for overflow. If the value of luckybuyTracker_ becomes too large, it may cause an integer overflow and result in incorrect calculations. This can be exploited by a malicious user to manipulate the contract's state and gain an unfair advantage."
        },
        {
            "function_name": "luckyBuy",
            "code": "function luckyBuy() private view returns(bool) { uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add (((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now))).add (block.gaslimit).add (((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now))).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) < luckybuyTracker_) return(true); else return(false); }",
            "vulnerability": "Integer Overflow",
            "reason": "The function luckyBuy has an integer overflow vulnerability. The variable luckybuyTracker_ is incremented by 1 when a user buys hearts with a value of 100000000000000000 or more. However, the variable luckybuyTracker_ is not checked for overflow. If the value of luckybuyTracker_ becomes too large, it may cause an integer overflow and result in incorrect calculations. This can be exploited by a malicious user to manipulate the contract's state and gain an unfair advantage."
        },
        {
            "function_name": "getMyRevenue",
            "code": "function getMyRevenue(uint _round) public view returns(uint256) { return(  (((RoundPayMask[_round]).mul(RoundMyHeart[_round][msg.sender])) / (1000000000000000000)).sub(RoundMyPayMask[_round][msg.sender])  ); }",
            "vulnerability": "Integer Overflow",
            "reason": "The function getMyRevenue has an integer overflow vulnerability. The variable RoundPayMask[_round] is multiplied by RoundMyHeart[_round][msg.sender] and then divided by 1000000000000000000. However, the variable RoundPayMask[_round] is not checked for overflow. If the value of RoundPayMask[_round] becomes too large, it may cause an integer overflow and result in incorrect calculations. This can be exploited by a malicious user to manipulate the contract's state and gain an unfair advantage."
        },
        {
            "function_name": "getMyRevenue",
            "code": "function getMyRevenue(uint _round) public view returns(uint256) { return(  (((RoundPayMask[_round]).mul(RoundMyHeart[_round][msg.sender])) / (1000000000000000000)).sub(RoundMyPayMask[_round][msg.sender])  ); }",
            "vulnerability": "Integer Overflow",
            "reason": "The function getMyRevenue has an integer overflow vulnerability. The variable RoundPayMask[_round] is multiplied by RoundMyHeart[_round][msg.sender] and then divided by 1000000000000000000. However, the variable RoundPayMask[_round] is not checked for overflow. If the value of RoundPayMask[_round] becomes too large, it may cause an integer overflow and result in incorrect calculations. This can be exploited by a malicious user to manipulate the contract's state and gain an unfair advantage."
        },
        {
            "function_name": "getMyRevenue",
            "code": "function getMyRevenue(uint _round) public view returns(uint256) { return(  (((RoundPayMask[_round]).mul(RoundMyHeart[_round][msg.sender])) / (1000000000000000000)).sub(RoundMyPayMask[_round][msg.sender])  ); }",
            "vulnerability": "Integer Overflow",
            "reason": "The function getMyRevenue has an integer overflow vulnerability. The variable RoundPayMask[_round] is multiplied by RoundMyHeart[_round][msg.sender] and then divided by 1000000000000000000. However, the variable RoundPayMask[_round] is not checked for overflow. If the value of RoundPayMask[_round] becomes too large, it may cause an integer overflow and result in incorrect calculations. This can be exploited by a malicious user to manipulate the contract's state and gain an unfair advantage."
        }
    ]
}