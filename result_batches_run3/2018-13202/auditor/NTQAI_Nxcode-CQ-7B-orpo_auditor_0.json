{
    "output_list": [
        {
            "function_name": "transfer",
            "code": "function transfer(address _to, uint256 _value) { if (balanceOf[msg.sender] < _value) throw;           
    if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
    balanceOf[msg.sender] -= _value;                     
    balanceOf[_to] += _value;                            
    Transfer(msg.sender, _to, _value);                   
  }",
            "vulnerability": "Integer Overflow",
            "reason": "The transfer function does not check if the recipient's balance will overflow. If the recipient's balance is greater than the maximum possible value for a uint256, the transfer will fail and the sender's balance will be reduced by the amount that failed to be transferred. This can be exploited by an attacker to steal tokens from the recipient."
        },
        {
            "function_name": "transferFrom",
            "code": "function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balanceOf[_from] < _value) throw;                 
    if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
    if (_value > allowance[_from][msg.sender]) throw;   
    balanceOf[_from] -= _value;                          
    balanceOf[_to] += _value;                            
    allowance[_from][msg.sender] -= _value;Transfer(_from, _to, _value);
    return true;}",
            "vulnerability": "Integer Overflow",
            "reason": "The transferFrom function does not check if the recipient's balance will overflow. If the recipient's balance is greater than the maximum possible value for a uint256, the transfer will fail and the sender's balance will be reduced by the amount that failed to be transferred. This can be exploited by an attacker to steal tokens from the recipient."
        },
        {
            "function_name": "buy",
            "code": "function buy() payable { uint amount = msg.value / buyPrice;                
    if (balanceOf[this] < amount) throw;               
    balanceOf[msg.sender] += amount;                   
    balanceOf[this] -= amount;                         
    Transfer(this, msg.sender, amount);                }",
            "vulnerability": "Integer Overflow",
            "reason": "The buy function does not check if the contract's balance will overflow. If the contract's balance is greater than the maximum possible value for a uint256, the buy will fail and the sender's balance will be reduced by the amount that failed to be purchased. This can be exploited by an attacker to steal tokens from the contract."
        },
        {
            "function_name": "sell",
            "code": "function sell(uint256 amount) { if (balanceOf[msg.sender] < amount ) throw;        
    balanceOf[this] += amount;                         
    balanceOf[msg.sender] -= amount;                   
    if (!msg.sender.send(amount * sellPrice)) {        
      throw;                                         
    } else {                                           
      Transfer(msg.sender, this, amount);            
    }                                                  }",
            "vulnerability": "Integer Overflow",
            "reason": "The sell function does not check if the contract's balance will overflow. If the contract's balance is greater than the maximum possible value for a uint256, the sell will fail and the sender's balance will be reduced by the amount that failed to be sold. This can be exploited by an attacker to steal tokens from the contract."
        },
        {
            "function_name": "burn",
            "code": "function burn(uint256 amount) onlyOwner returns (bool success) { if (balanceOf[msg.sender] < amount) throw;            
    balanceOf[msg.sender] -= amount;                      
    totalSupply -= amount;                                
    Burn(msg.sender, amount);                            
    return true;}",
            "vulnerability": "Integer Overflow",
            "reason": "The burn function does not check if the total supply will overflow. If the total supply is greater than the maximum possible value for a uint256, the burn will fail and the sender's balance will be reduced by the amount that failed to be burned. This can be exploited by an attacker to steal tokens from the contract."
        }
    ]
}