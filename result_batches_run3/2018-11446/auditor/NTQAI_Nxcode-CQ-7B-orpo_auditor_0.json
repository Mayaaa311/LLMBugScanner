{
    "output_list": [
        {
            "function_name": "increaseTotalSupply",
            "code": "function increaseTotalSupply (address target,  uint256 increaseBy )  onlyOwner { balanceOf[target] += increaseBy; totalSupply += increaseBy; Transfer(0, owner, increaseBy); Transfer(owner, target, increaseBy); }",
            "vulnerability": "Integer Overflow",
            "reason": "The function increaseTotalSupply is vulnerable to integer overflow. The code does not check if the sum of balanceOf[target] and increaseBy exceeds the maximum value that can be stored in a uint256. This could lead to an incorrect totalSupply and potentially incorrect balances for the target address."
        },
        {
            "function_name": "transfer",
            "code": "function transfer(address _to, uint256 _value) notICO { require(!frozen[msg.sender]); if (msg.sender.balance  < minBalanceForAccounts) { sell((minBalanceForAccounts - msg.sender.balance) * sellPrice); } _transfer(msg.sender, _to, _value); }",
            "vulnerability": "Integer Overflow",
            "reason": "The function transfer is vulnerable to integer overflow. The code does not check if the sum of balanceOf[_from] and _value exceeds the maximum value that can be stored in a uint256. This could lead to an incorrect balance for the _from address."
        },
        {
            "function_name": "reward",
            "code": "function reward(address _to, uint256 _value, bool locked, string data) { require(_to != 0x0); require(!frozen[msg.sender]); if (msg.sender.balance  < minBalanceForAccounts) { sell((minBalanceForAccounts - msg.sender.balance) * sellPrice); } if(!locked) { _transfer(msg.sender, _to, _value); }else{ require(balanceOf[msg.sender] >= _value); require(totalLockedRewardsOf[_to] + _value > totalLockedRewardsOf[_to]); balanceOf[msg.sender] -= _value; totalLockedRewardsOf[_to] += _value; lockedRewardsOf[_to][msg.sender] += _value; if(userRewardCount[_to][msg.sender]==0) { userRewarderCount[_to] += 1; userRewarders[_to][userRewarderCount[_to]]=msg.sender; } userRewardCount[_to][msg.sender]+=1; totalRewardIssuedOut[msg.sender]+= _value; Transfer(msg.sender, _to, _value); } Reward(msg.sender, _to, _value, data, now); }",
            "vulnerability": "Integer Overflow",
            "reason": "The function reward is vulnerable to integer overflow. The code does not check if the sum of balanceOf[msg.sender] and _value exceeds the maximum value that can be stored in a uint256. This could lead to an incorrect balance for the msg.sender address."
        },
        {
            "function_name": "transferFrom",
            "code": "function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(!frozen[_from]); require(_value <= allowance[_from][msg.sender]);     allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; }",
            "vulnerability": "Integer Overflow",
            "reason": "The function transferFrom is vulnerable to integer overflow. The code does not check if the sum of balanceOf[_from] and _value exceeds the maximum value that can be stored in a uint256. This could lead to an incorrect balance for the _from address."
        },
        {
            "function_name": "burn",
            "code": "function burn(uint256 _value) onlyOwner returns (bool success) { require(balanceOf[msg.sender] >= _value);   balanceOf[msg.sender] -= _value;            totalSupply -= _value;                      Burn(msg.sender, _value); return true; }",
            "vulnerability": "Integer Overflow",
            "reason": "The function burn is vulnerable to integer overflow. The code does not check if the sum of balanceOf[msg.sender] and _value exceeds the maximum value that can be stored in a uint256. This could lead to an incorrect balance for the msg.sender address and potentially incorrect totalSupply."
        }
    ]
}