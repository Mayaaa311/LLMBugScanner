 
{
    "output_list": [
        {
            "function_name": "totalSupply",
            "code": "function totalSupply() constant returns (uint256 totSupply) { return _totalSupply; }",
            "vulnerability": "Integer Overflow",
            "reason": "The totalSupply function does not check for integer overflow. If the total supply of tokens exceeds the maximum value that can be stored in a uint256, the function will return an incorrect result. This can be exploited by an attacker to mint more tokens than the total supply."
        },
        {
            "function_name": "transfer",
            "code": "function transfer(address _to, uint256 _amount) notThisContract(_to) returns (bool success) { require(_to != 0x0); require(_amount > 0); require(balances[msg.sender] >= _amount); require(balances[_to] + _amount > balances[_to]); balances[msg.sender] -= _amount; balances[_to] += _amount; Transfer(msg.sender, _to, _amount); return true; }",
            "vulnerability": "Integer Overflow",
            "reason": "The transfer function does not check for integer overflow when adding the transferred amount to the recipient's balance. If the recipient's balance exceeds the maximum value that can be stored in a uint256, the function will return an incorrect result. This can be exploited by an attacker to transfer more tokens than they have."
        },
        {
            "function_name": "transferFrom",
            "code": "function transferFrom(address _from, address _to, uint256 _amount) notThisContract(_to) returns (bool success) { require(balances[_from] >= _amount); require(allowed[_from][msg.sender] >= _amount); require(_amount > 0); require(balances[_to] + _amount > balances[_to]); balances[_from] -= _amount; allowed[_from][msg.sender] -= _amount; balances[_to] += _amount; Transfer(_from, _to, _amount); return true; }",
            "vulnerability": "Integer Overflow",
            "reason": "The transferFrom function does not check for integer overflow when adding the transferred amount to the recipient's balance. If the recipient's balance exceeds the maximum value that can be stored in a uint256, the function will return an incorrect result. This can be exploited by an attacker to transfer more tokens than they have."
        },
        {
            "function_name": "increaseApproval",
            "code": "function increaseApproval (address _spender, uint _addedValue) returns (bool success) { allowed[msg.sender][_spender] += _addedValue; Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; }",
            "vulnerability": "Integer Overflow",
            "reason": "The increaseApproval function does not check for integer overflow when adding the approved amount to the spender's allowance. If the spender's allowance exceeds the maximum value that can be stored in a uint256, the function will return an incorrect result. This can be exploited by an attacker to approve more tokens than they have."
        },
        {
            "function_name": "decreaseApproval",
            "code": "function decreaseApproval (address _spender, uint _subtractedValue) returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] -= _subtractedValue; } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; }",
            "vulnerability": "Integer Overflow",
            "reason": "The decreaseApproval function does not check for integer overflow when subtracting the approved amount from the spender's allowance. If the spender's allowance exceeds the maximum value that can be stored in a uint256, the function will return an incorrect result. This can be exploited by an attacker to approve fewer tokens than they have."
        }
    ]
}